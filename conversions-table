#!/usr/bin/perl -w
use strict;
our $copyright = <<END;
    Copyright 2021 Ian Jackson and contributors
    SPDX-License-Identifier: MIT
    There is NO WARRANTY.
END

my $approx = "≈";
my $approx_accute = "⩯";

# <   might truncate even positive values (might imply +)
# +   might add 2^n to make positive via twos-complement
# ⁉   might produce saturated integer values, and ignore NaN
# ≈   might round
# ⩯   might round or give Inf

sub results ($$) {
  my ($t1,$t2) = @_;
  my $c = "$t1,$t2";
  my ($k1,$w1, $k2,$w2) = $c =~ m/^([iuf])(\w+),([iuf])(\w+)$/ or die;
  $w2 = $w1 eq $w2 ? 1024 : 1 if $w2 =~ m/\D/;
  $w1 =              1024     if $w1 =~ m/\D/;
  if ("$k1$k2" =~ m/^[iu]+$/) {
    if ($w1 eq $w2) {
      if ($k1 eq $k2) {
	return "F "; # equal types
      } elsif ("$k1$k2" =~ m/ui/) { # uW -> iW, losing a bit
	return "t<";
      } elsif ("$k1$k2" =~ m/iu/) { # iW -> uW, might add 2^W
	return "t+";
      } else {
	die;
      }
    } else { # different types of known or assumed bit-width
      if ($w1 > $w2) {
	return "t<";
      } elsif ($w2 > $w1) {
	if ("$k1$k2" =~ m/iu/) { # iW -> uW, might add 2^W
	  return "t+";
	} else {
	  return "F ";
	}
      } else {
	die;
      }
    }
  } elsif ($c =~ m/^f.*,[iu].*$/) {
    return "N≠";
  } elsif ($k2 eq 'f') {
    if ($k1 eq 'f') {
      return $w2 >= $w1 ? "F " : "N⩯"
    } elsif ($k1 =~ m/[iu]/) {
      if ($w2 > $w1) { # space for exponent
	return "F ";
      } elsif ($w2 == 32 && $t1 =~ m/^(?:u128|.size)$/) {
	return "N⩯";
      } else {
	return "N≈";
      }
    }
  } else {
    die "$c ?";
  }
}

my @sizes = qw(8 16 32 64 128 size);
my @fsizes = qw(32 64);

# abstract, input to formatter
my @abstr_corner = ('to', 'from');
my @abstr_col_groups;
# $abstr_col_groups[]{Head0} = 'i', 'u', or 'f'
# $abstr_col_groups[]{Head1}[] = '8', ..., '128', 'size'
# $abstr_col_groups[]{Data}[][] = '.', 'T<', 'n≈' etc.
my @abstr_row_groups;
# $abstr_row_groups[][]{Head} = 'i8', 'i16', ...

sub iterate_rows ($$$) {
  my ($f_group_start, $f_data_row, $f_group_end) = @_;
  # calls
  #  $f_group_start->()
  #  $f_data_row->($head, $di) # use $abstr_col_groups[]{Data}[$di]
  #  $f_group_end->()
  my $di= 0;
  for my $rgroup (@abstr_row_groups) {
    $f_group_start->();
    foreach my $row (@$rgroup) {
      $f_data_row->($row->{Head}, $di++);
    }
    $f_group_end->()
  }
}

@abstr_col_groups = ({
  Head0 => 'i', 
  Head1 => \@sizes,
  Data => [],
}, {
  Head0 => 'u', 
  Head1 => \@sizes,
  Data => [],
}, {
  Head0 => 'f', 
  Head1 => \@fsizes,
  Data => [],
});

foreach my $cgroup (@abstr_col_groups) {
  push @abstr_row_groups, [map {
    { Head => $cgroup->{Head0}.$_ },
  } @{ $cgroup->{Head1} }];
}

#use Data::Dumper;
#print Dumper(\@abstr_col_groups, \@abstr_row_groups);
#exit 0;

print "   to";
foreach my $cgroup (@abstr_col_groups) {
  print " |";
  printf " %4s%*s", $cgroup->{Head0}, 5* (-1 + scalar @{ $cgroup->{Head1} }), "";
}
print "\n";

my @types;
my $hl = <<END;
------+-------------------------------+-------------------------------+-----------
END

print "from  |";
foreach my $s (@sizes) {
  push @types, "i$s";
  printf " %4s", $s;
}
print " |";
foreach my $s (@sizes) {
  push @types, "u$s";
  printf " %4s", $s;
}
print " |";
foreach my $s (qw(32 64)) {
  push @types, "f$s";
  printf " %4s", $s;
}
print "\n";
print $hl;

sub chg { $_[0] =~ m/^(?:u8|f32)$/ }

foreach my $t1 (@types) {
  print $hl if chg($t1);
  printf "%5s |", $t1 or die $!;
  foreach my $t2 (@types) {
    print " |" if chg($t2);
    print " ";
    my $r = results($t1, $t2);
    if ($r eq 'F ') {
      print ".   ";
    } elsif ($r =~ m/^t/) {
      print "T$'  ";
    } elsif ($r =~ m/^N/) {
      print "n$'  ";
    } else {
      printf "%3s", $r;
    }
  }
  print "\n" or die $!;
}
