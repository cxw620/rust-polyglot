#!/usr/bin/perl -w
use strict;
our $copyright = <<END;
    Copyright 2021 Ian Jackson and contributors
    SPDX-License-Identifier: MIT
    There is NO WARRANTY.
END

my $approx = "≈";
my $approx_accute = "⩯";

# <   might truncate even positive values (might imply +)
# +   might add 2^n to make positive via twos-complement
# ⁉   might produce saturated integer values, and ignore NaN
# ≈   might round
# ⩯   might round or give Inf

sub results ($$) {
  my ($t1,$t2) = @_;
  my $c = "$t1,$t2";
  my ($k1,$w1, $k2,$w2) = $c =~ m/^([iuf])(\w+),([iuf])(\w+)$/ or die;
  $w2 = $w1 eq $w2 ? 1024 : 1 if $w2 =~ m/\D/;
  $w1 =              1024     if $w1 =~ m/\D/;
  if ("$k1$k2" =~ m/^[iu]+$/) {
    if ($w1 eq $w2) {
      if ($k1 eq $k2) {
	return "F "; # equal types
      } elsif ("$k1$k2" =~ m/ui/) { # uW -> iW, losing a bit
	return "t<";
      } elsif ("$k1$k2" =~ m/iu/) { # iW -> uW, might add 2^W
	return "t+";
      } else {
	die;
      }
    } else { # different types of known or assumed bit-width
      if ($w1 > $w2) {
	return "t<";
      } elsif ($w2 > $w1) {
	if ("$k1$k2" =~ m/iu/) { # iW -> uW, might add 2^W
	  return "t+";
	} else {
	  return "F ";
	}
      } else {
	die;
      }
    }
  } elsif ($c =~ m/^f.*,[iu].*$/) {
    return "N≠";
  } elsif ($k2 eq 'f') {
    if ($k1 eq 'f') {
      return $w2 >= $w1 ? "F " : "N⩯"
    } elsif ($k1 =~ m/[iu]/) {
      if ($w2 > $w1) { # space for exponent
	return "F ";
      } elsif ($w2 == 32 && $t1 =~ m/^(?:u128|.size)$/) {
	return "N⩯";
      } else {
	return "N≈";
      }
    }
  } else {
    die "$c ?";
  }
}

my @types;
my @sizes = qw(8 16 32 64 128 size);

print <<END;
   to |    i                          |    u                          |   f
END
my $hl = <<END;
------+-------------------------------+-------------------------------+-----------
END

print "from  |";
foreach my $s (@sizes) {
  push @types, "i$s";
  printf " %4s", $s;
}
print " |";
foreach my $s (@sizes) {
  push @types, "u$s";
  printf " %4s", $s;
}
print " |";
foreach my $s (qw(32 64)) {
  push @types, "f$s";
  printf " %4s", $s;
}
print "\n";
print $hl;

sub chg { $_[0] =~ m/^(?:u8|f32)$/ }

foreach my $t1 (@types) {
  print $hl if chg($t1);
  printf "%5s |", $t1 or die $!;
  foreach my $t2 (@types) {
    print " |" if chg($t2);
    print " ";
    my $r = results($t1, $t2);
    if ($r eq 'F ') {
      print ".   ";
    } elsif ($r =~ m/^t/) {
      print "T$'  ";
    } elsif ($r =~ m/^N/) {
      print "n$'  ";
    } else {
      printf "%3s", $r;
    }
  }
  print "\n" or die $!;
}
