#!/usr/bin/perl -w
use strict;
our $copyright = <<END;
    Copyright 2021 Ian Jackson and contributors
    SPDX-License-Identifier: MIT
    There is NO WARRANTY.
END

my $approx = "≈";
my $approx_accute = "⩯";

# !   might truncate even positive values (might imply +)
# +   might add 2^n to make positive via twos-complement
# ‼   might produce saturated integer values, and ignore NaN

sub results ($$) {
  my ($t1,$t2) = @_;
  my $c = "$t1,$t2";
  if (my ($t1,$w1, $t2,$w2) =
      $c =~ m/^([iu])(\w+),([iu])(\w+)$/) {
    if ($w1 eq $w2) {
      if ($t1 eq $t2) {
	return "F "; # equal types
      } elsif ("$t1$t2" =~ m/ui/) { # uW -> iW, losing a bit
	return "t!";
      } elsif ("$t1$t2" =~ m/iu/) { # iW -> uW, might add 2^W
	return "t+";
      } else {
	die;
      }
    } elsif ("$w1$w2" =~ m/\D/) { # at least one Tsize
      return "t!";
    } else { # different types of specific bit-width
      if ($w1 > $w2) {
	return "t!";
      } elsif ($w2 > $w1) {
	if ("$t1$t2" =~ m/iu/) { # iW -> uW, might add 2^W
	  return "t+";
	} else {
	  return "F ";
	}
      } else {
	die;
      }
    }
  } elsif ($c =~ m/^f.*,[iu].*$/) {
    return "N‼";
  } else {
    return "@@";
  }
}

my @types;
my @sizes = qw(8 16 32 64 128 size);
foreach my $s (@sizes) {
  push @types, "i$s", "u$s";
}
push @types, qw(f32 f64);

print <<END;
       | i   u | i   u | i   u | i   u | i   u | i   u |   f   |
       |    8  |   16  |   32  |   64  |  128  |  size | 32 64 |
-------+-------+-------+-------+-------+-------+-------+-------+
END

foreach my $t1 (@types) {
  printf "%5s  |", $t1 or die $!;
  foreach my $t2 (@types) {
    print " ", results($t1, $t2), " " or die $!;
  }
  print "\n" or die $!;
}
