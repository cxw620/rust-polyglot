#!/usr/bin/perl -w
use strict;
our $copyright = <<END;
    Copyright 2021 Ian Jackson and contributors
    SPDX-License-Identifier: MIT
    There is NO WARRANTY.
END

use POSIX;
our $src = "src";

#---------- input data and templates ----------

our $title = "DRAFT - Rust for the Polyglot Programmer";
our @chapters;

our @crate_refs_docs_rs = qw(
   anyhow
   arrayvec
   crossbeam
   easy-ext
   eyre
   index_vec
   indexmap
   num-derive
   thiserror
   chrono
   chrono-tz
   lazy_static
   once_cell
   tracing
   lazy-regex
   log
   glob
   tempfile
   reqwest
   hyper
   pyo3
   warp
   getopts
   gumdrop
   jni
   ring
);
our @crate_refs_crates_io = qw(
   generational_arena
   itertools
   num-traits
   num
   parking_lot
   rayon
   slab
   slotmap
   strum
   libc
   nix
   env_logger
   regex
   rand
   either
   void
   structopt
   clap
   argparse
   wasm-bindgen
   web-sys
   rusty_v8
   j4rs
   rustls
);

our $precontents = <<END;
Rust for the experienced programmer, a DRAFT guide.

See the [Introduction](intro.md) for
the rubric, goals, and non-goals.
See the [Colophon](colophon.md) for
authorship and acknowledgements,
making contributions and corrections,
and document source code,

### THIS IS A DRAFT - FOR REVIEW BY THE RUST COMMUNITY

I would greatly appreciate feedback from fellow Rustaceans.

I am interested in reports of any or all of
 * Technical errors
 * Significant omissions
 * Duplication, redundancy, verbosity, or otioseness
 * Differences of opinion especially about crate recommendations,

See the [Colophon](colophon.md) for information about contributing
including a link to the Gitlab repo.

END

our $mdbook_refs = <<END;
{{ #include ../$src/refs.md }}
{{ #include autorefs.md }}
END

#---------- output generation functions ----------

# variables that come from the parser
our @sections;

sub summary() {
  start_output("mdbook/SUMMARY.md");
  ol("# $title");
  o_autogen();
  ol(" - [Contents](README.md)");
  foreach my $section (@sections) {
    next if $section->[0];
    ol(" - [$section->[2]]($section->[1])");
  }
  end_output();
}

sub contents() {
  start_output("mdbook/README.md");
  ol("# $title");
  o_autogen();
  o(<<END);
$precontents

## Table of Contents

END

  for my $section (@sections) {
    o("  " x (1 + $section->[0]));
    o(" - [$section->[2]]($section->[1]");
    if ($section->[0]) {
      my $lref = $section->[2];
      $lref =~ s/[^ \w]//g;
      $lref =~ s/ /-/g;
      $lref = lc $lref;
      o("#$lref");
    }
    ol(")");
  }
  o("\n$mdbook_refs");
  end_output();
}

sub autorefs() {
  start_output("mdbook/autorefs.md");
  foreach my $crate (@crate_refs_docs_rs) {
    my $rustc_crate = $crate;
    $rustc_crate =~ y/-/_/;
    ol("[\`$crate`]: https://docs.rs/$crate/latest/$rustc_crate/");
  }
  foreach my $crate (@crate_refs_crates_io) {
    ol("[\`$crate`]: https://crates.io/crates/$crate");
  }
  end_output();
}

sub append_to_colophon ($$) {
  my ($file, $title) = @_;
  ol();
  ol("#### $title (`$file`)");
  ol();
  ol('```');
  open F, "< $file" or die $!;
  while (<F>) { o($_); }
  F->error and die;
  close F;
  ol('```');
  ol();
}

#---------- input scanning ----------

our @output_files;
our $comment_re = qr{^\Q[comment]:};

sub scan_filter() {
  foreach my $chap (@chapters) {
    if (stat "$src/$chap.rst") { warn "$chap still RST!"; next; }

    my @csections;

    my $leaf = "$chap.md";

    open MD, "> mdbook/$leaf.tmp" or die $!;
    push @output_files, "mdbook/$leaf";

    open C, "$src/$leaf" or die "$src/$leaf $!";
    my $last_l;
    while (<C>) {
      print MD or die $! unless m{$comment_re};

      if (!m/\S/ && defined($last_l) && $last_l =~ m{$comment_re}) {
	autogen_any("$src/$leaf", sub { print MD @_, "\n" or die $!; });
	print MD "\n" or die $!;
      }

      s{\s+$}{};
      # Extract section headings
      my $new_last_l;
      if (m{^---+$} || m{^===+$}) {
	my $level = 0 + !!m{^---};
	push @csections, [ $level, $leaf, ($last_l // die) ];
      } elsif (m{^(\#+) (\S.*\S)}) {
	my $level = -1 + length $1;
	push @csections, [ $level, $leaf, $2 ];
      } else {
	die if $.==2;
	$new_last_l = $_;
      }
      $last_l = $new_last_l;
    }
    C->error and die $!;

    if ($leaf eq 'colophon.md') {
      open O, ">&MD" or die $!;
      append_to_colophon('LICENCE',
			 'Full copyright notice');
      append_to_colophon('DEVELOPER-CERTIFICATE',
			 'Developer Certificate of Origin');
      ol("---");
      ol("formatted ".
	 strftime("%Y-%m-%d %H:%M:%S UTC", gmtime time));
      ol();
      my $git_commit = `git rev-parse HEAD` || die "$? $!";
      chomp $git_commit;
      $?=0; $!=0; my $status = `git status --porcelain`;
      die "$? $!" if $? || $!;
      ol("git commit `$git_commit`". (length($status) ? "; tree dirty" : ""));
      close O or die $!;
    }

    print MD "\n\n$mdbook_refs" or die $!;
    close MD or die $!;

    push @sections, @csections;
  }
}

#---------- machinery and main program ----------

our $current_output_file;

sub start_output ($) {
  die if defined $current_output_file;
  $current_output_file = "$_[0]";
  open O, "> $current_output_file.tmp" or die "$current_output_file.tmp $!";
}
sub o {
  print O @_ or die $!;
}
sub ol {
  o(@_);
  o("\n");
}
sub autogen_any ($$) {
  my ($instead, $f) = @_;
  foreach my $l ("*** WARNING - AUTOGENERATED FILE ***",
		 "*** EDIT $instead INSTEAD ***",
		 "",
		 (split /\n/, $copyright),
		 ) {
    my $l = $l;
    $l =~ s/^\s+//;
    $l =~ s/\s+$//;
    $l = sprintf "%-60s", $l;
    $f->("[comment]: # ( $l )");
  }
}
sub o_autogen {
  ol();
  autogen_any($0, \&ol);
  ol();
}

sub end_output () {
  die unless defined $current_output_file;
  close O or die $!;
  push @output_files, $current_output_file;
  $current_output_file = undef;
}

sub install_outputs () {
  foreach my $o (@output_files) {
    rename "$o.tmp", $o or die "$o $!";
  }
}

die unless @ARGV;
die if $ARGV[0] =~ m/^-/;
@chapters = @ARGV;

foreach my $sd (qw(mdbook pandoc)) {
  mkdir $sd or $!==EEXIST or die $!;
}
scan_filter();
summary();
contents();
autorefs();
install_outputs();
