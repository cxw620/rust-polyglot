#!/usr/bin/perl -w
use strict;
our $copyright = <<END;
    Copyright 2021 Ian Jackson and contributors
    SPDX-License-Identifier: MIT
    There is NO WARRANTY.
END

use POSIX;
our $src = "src";

#---------- input data and templates ----------

our $title = "DRAFT - Rust for the Polyglot Programmer";

our @chapters = qw(
   intro
   syntax
   types
   ownership
   traits
   safety
   errors
   macros
   async
   rustdoc
   stability
   cargo
   libs
   further
   colophon
);

our $precontents = <<END;
Rust for the experienced programmer, a DRAFT guide.

See the [Introduction](intro.md) for
the rubric, goals, and non-goals.
See the [Colophon](colophon.md) for
authorship, making contributions and corrections,
and document source code,
END

our $mdbook_refs = "{{ #include ../$src/refs.md }}";

#---------- output generation functions ----------

# variables that come from the parser
our @sections;

sub summary() {
  start_output("mdbook/SUMMARY.md");
  ol("# $title");
  o_autogen();
  ol(" - [Contents](CONTENTS.md)");
  foreach my $section (@sections) {
    next if $section->[0];
    ol(" - [$section->[2]]($section->[1])");
  }
  end_output();
}

sub contents() {
  start_output("mdbook/CONTENTS.md");
  ol("# $title");
  o_autogen();
  o(<<END);
$precontents

## Table of Contents

END

  for my $section (@sections) {
    o("  " x (1 + $section->[0]));
    o(" - [$section->[2]]($section->[1]");
    if ($section->[0]) {
      my $lref = $section->[2];
      $lref =~ s/[^ \w]//g;
      $lref =~ s/ /-/g;
      $lref = lc $lref;
      o("#$lref");
    }
    ol(")");
  }
  ol("\n$mdbook_refs");
  end_output();
}

#---------- input scanning ----------

our @output_files;
our $comment_re = qr{^\Q[comment]:};

sub scan_filter() {
  foreach my $chap (@chapters) {
    if (stat "$src/$chap.rst") { warn "$chap still RST!"; next; }

    my @csections;

    my $leaf = "$chap.md";

    open MD, "> mdbook/$leaf.tmp" or die $!;
    push @output_files, "mdbook/$leaf";

    open C, "$src/$leaf" or die "$src/$leaf $!";
    my $last_l;
    while (<C>) {
      print MD or die $! unless m{$comment_re};

      if (!m/\S/ && defined($last_l) && $last_l =~ m{$comment_re}) {
	autogen_any("$src/$leaf", sub { print MD @_, "\n" or die $!; });
	print MD "\n" or die $!;
      }

      s{\s+$}{};
      # Extract section headings
      my $new_last_l;
      if (m{^---+$} || m{^===+$}) {
	my $level = 0 + !!m{^---};
	push @csections, [ $level, $leaf, ($last_l // die) ];
      } elsif (m{^(\#+) (\S.*\S)}) {
	my $level = -1 + length $1;
	push @csections, [ $level, $leaf, $2 ];
      } else {
	die if $.==2;
	$new_last_l = $_;
      }
      $last_l = $new_last_l;
    }

    print MD "\n\n$mdbook_refs\n" or die $!;
    close MD or die $!;

    push @sections, @csections;
  }
}

#---------- machinery and main program ----------

our $current_output_file;

sub start_output ($) {
  die if defined $current_output_file;
  $current_output_file = "$_[0]";
  open O, "> $current_output_file.tmp" or die "$current_output_file.tmp $!";
}
sub o {
  print O @_ or die $!;
}
sub ol {
  o(@_);
  o("\n");
}
sub autogen_any ($$) {
  my ($instead, $f) = @_;
  foreach my $l ("*** WARNING - AUTOGENERATED FILE ***",
		 "*** EDIT $instead INSTEAD ***",
		 "",
		 (split /\n/, $copyright),
		 ) {
    my $l = $l;
    $l =~ s/^\s+//;
    $l =~ s/\s+$//;
    $l = sprintf "%-60s", $l;
    $f->("[comment]: # ( $l )");
  }
}
sub o_autogen {
  ol();
  autogen_any($0, \&ol);
  ol();
}

sub end_output () {
  die unless defined $current_output_file;
  close O or die $!;
  push @output_files, $current_output_file;
  $current_output_file = undef;
}

sub install_outputs () {
  foreach my $o (@output_files) {
    rename "$o.tmp", $o or die "$o $!";
  }
}

mkdir "mdbook" or $!==EEXIST or die $!;
scan_filter();
summary();
contents();
install_outputs();
